<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Steeriously: steer Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="steeriously.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Steeriously
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">steer Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>All steering functions are templated for easy application to objects inheriting from <a class="el" href="classsteer_1_1_agent.html" title="The invisible, but highly necessary, automaton which drives your *game entity/graphical representatio...">Agent</a>. Because of this, it is easy to add into any type of design - be it a class hierarchy or a more advanced data structure or system (such as an entity component system). All functions return a steer::steer::Vector2 that can be used to calculate a force with which the entity should be moved given each type of behavior. Combine each calculated force with a weight (any scalar value - but keep it sane or behavior could become strange). Simply multiply each weight, or weights, by the force generated by each behavior's return value to fine-tune it. In addition to the steering functions themselves, this file contains various utilities used by them to perform their work.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_agent.html">Agent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The invisible, but highly necessary, automaton which drives your *game entity/graphical representation's motion. Getters and Setters are provided, *however it will always be easier to just use the data - since it is all public.  <a href="classsteer_1_1_agent.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsteer_1_1_behavior_parameters.html">BehaviorParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data table with default values used to define variables for guiding steerable objects (agents).  <a href="structsteer_1_1_behavior_parameters.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_arrive_component.html">ArriveComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the arrive steering behavior. The agent will seek the target with a dampened arrival.  <a href="classsteer_1_1_arrive_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_evade_component.html">EvadeComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the evasion steering behavior. The agent will flee from the target while predicting it's trajectory.  <a href="classsteer_1_1_evade_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_flee_component.html">FleeComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the flee steering behavior. The agent will flee from the target when it enters its threat range.  <a href="classsteer_1_1_flee_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_flocking_component.html">FlockingComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the flocking steering behavior. The agent will interact with other members of the flock utilizing alignment, separation, cohesion, and wandering behaviors.  <a href="classsteer_1_1_flocking_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_hide_component.html">HideComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the hiding steering behavior.  <a href="classsteer_1_1_hide_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_interpose_component.html">InterposeComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the interpose steering behavior.  <a href="classsteer_1_1_interpose_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_offset_pursuit_component.html">OffsetPursuitComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the offset pursuit steering behavior.  <a href="classsteer_1_1_offset_pursuit_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_path_following_component.html">PathFollowingComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the path following steering behavior.  <a href="classsteer_1_1_path_following_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_pursuit_component.html">PursuitComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the pursuit steering behavior.  <a href="classsteer_1_1_pursuit_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_seek_component.html">SeekComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the seek steering behavior.  <a href="classsteer_1_1_seek_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_super_component.html">SuperComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the an agent with every steering behavior implemented.  <a href="classsteer_1_1_super_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_wander_component.html">WanderComponent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An example implementation of the wander steering behavior.  <a href="classsteer_1_1_wander_component.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_matrix2_d.html">Matrix2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for 2D matrices and related operations.  <a href="classsteer_1_1_matrix2_d.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_path.html">Path</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class providing the necessary structure for path following behavior.  <a href="classsteer_1_1_path.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_sphere_obstacle.html">SphereObstacle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to aid in obstacle avoidance routine.  <a href="classsteer_1_1_sphere_obstacle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsteer_1_1_vector2.html">Vector2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A 2D vector struct used in many steering calculations.  <a href="structsteer_1_1_vector2.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_vector_math.html">VectorMath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stateless <a class="el" href="classsteer_1_1_vector_math.html" title="Stateless VectorMath class utilizing static methods to manipulate vectors.  Copies of Vector2 are che...">VectorMath</a> class utilizing static methods to manipulate vectors. <br/>
Copies of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">Vector2</a> are cheap, therefore all functions are "pass by value" at this time.  <a href="classsteer_1_1_vector_math.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsteer_1_1_wall.html">Wall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for constructing 2D walls for wall avoidance behaviors.  <a href="classsteer_1_1_wall.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac624bd4d8a4c5c8cec38cb037962696c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac624bd4d8a4c5c8cec38cb037962696c"></a>
typedef signed char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#ac624bd4d8a4c5c8cec38cb037962696c">Int8</a></td></tr>
<tr class="memdesc:ac624bd4d8a4c5c8cec38cb037962696c"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; Useful typedefs for signed/unsigned integers. <br/></td></tr>
<tr class="separator:ac624bd4d8a4c5c8cec38cb037962696c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b608712afd89174dd4bbb50c35ab70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15b608712afd89174dd4bbb50c35ab70"></a>
typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>Uint8</b></td></tr>
<tr class="separator:a15b608712afd89174dd4bbb50c35ab70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f62ea8587b74f423b3112a633a3c8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32f62ea8587b74f423b3112a633a3c8f"></a>
typedef signed short&#160;</td><td class="memItemRight" valign="bottom"><b>Int16</b></td></tr>
<tr class="separator:a32f62ea8587b74f423b3112a633a3c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203b74e59ae2cd122624a0f8fdd0ac69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a203b74e59ae2cd122624a0f8fdd0ac69"></a>
typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>Uint16</b></td></tr>
<tr class="separator:a203b74e59ae2cd122624a0f8fdd0ac69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0f7ba830c800fa6d940c46b8b1aa36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e0f7ba830c800fa6d940c46b8b1aa36"></a>
typedef signed int&#160;</td><td class="memItemRight" valign="bottom"><b>Int32</b></td></tr>
<tr class="separator:a1e0f7ba830c800fa6d940c46b8b1aa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5daf8c35e087eb70c1d5378f62617f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf5daf8c35e087eb70c1d5378f62617f"></a>
typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>Uint32</b></td></tr>
<tr class="separator:aaf5daf8c35e087eb70c1d5378f62617f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ece6b46d4f0fbc8d22248cdf350c00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09ece6b46d4f0fbc8d22248cdf350c00"></a>
typedef signed long long&#160;</td><td class="memItemRight" valign="bottom"><b>Int64</b></td></tr>
<tr class="separator:a09ece6b46d4f0fbc8d22248cdf350c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3437f640c793384ae68c4b453a6f21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d3437f640c793384ae68c4b453a6f21"></a>
typedef unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a3d3437f640c793384ae68c4b453a6f21">Uint64</a></td></tr>
<tr class="memdesc:a3d3437f640c793384ae68c4b453a6f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful constants for minimum and maximum values. <br/></td></tr>
<tr class="separator:a3d3437f640c793384ae68c4b453a6f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afe6e72f8f8088962727051501181acbe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#afe6e72f8f8088962727051501181acbe">behaviorType</a> { <br/>
&#160;&#160;<b>none</b> = 0x00000, 
<b>seek</b> = 0x00002, 
<b>flee</b> = 0x00004, 
<b>arrive</b> = 0x00008, 
<br/>
&#160;&#160;<b>wander</b> = 0x00010, 
<b>cohesion</b> = 0x00020, 
<b>separation</b> = 0x00040, 
<b>alignment</b> = 0x00080, 
<br/>
&#160;&#160;<b>obstacleAvoidance</b> = 0x00100, 
<b>wallAvoidance</b> = 0x00200, 
<b>followPath</b> = 0x00400, 
<b>pursuit</b> = 0x00800, 
<br/>
&#160;&#160;<b>evade</b> = 0x01000, 
<b>interpose</b> = 0x02000, 
<b>hide</b> = 0x04000, 
<b>flock</b> = 0x08000, 
<br/>
&#160;&#160;<b>offsetPursuit</b> = 0x10000
<br/>
 }</td></tr>
<tr class="memdesc:afe6e72f8f8088962727051501181acbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitfield for behavior types. Useful as a representation for combining behaviors. <br/></td></tr>
<tr class="separator:afe6e72f8f8088962727051501181acbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e7b3b5c0df931b74d0483b14ff2178"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a05e7b3b5c0df931b74d0483b14ff2178">Deceleration</a> { <b>slow</b> = 3, 
<b>normal</b> = 2, 
<b>fast</b> = 1
 }</td></tr>
<tr class="memdesc:a05e7b3b5c0df931b74d0483b14ff2178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for applying a scaling factor to deceleration. <br/></td></tr>
<tr class="separator:a05e7b3b5c0df931b74d0483b14ff2178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae984f1d102037f282e7029dd1f41a50f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#ae984f1d102037f282e7029dd1f41a50f">summingMethod</a> { <b>weightedSum</b> = 1, 
<b>prioritized</b> = 2, 
<b>dithered</b> = 3
 }</td></tr>
<tr class="memdesc:ae984f1d102037f282e7029dd1f41a50f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful for indicating what type of summation method to use for steering forces. <br/></td></tr>
<tr class="separator:ae984f1d102037f282e7029dd1f41a50f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc4f545047825b5b6068b5fd6a6579e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>clockwise</b> = 1, 
<b>anticlockwise</b> = -1
 }</td></tr>
<tr class="separator:adfc4f545047825b5b6068b5fd6a6579e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7d9e2cbba7557cca0a07982a322c89b2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7d9e2cbba7557cca0a07982a322c89b2"></a>
template&lt;class T , class conT &gt; </td></tr>
<tr class="memitem:a7d9e2cbba7557cca0a07982a322c89b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TagVehiclesWithinViewRange</b> (const T &amp;entity, const conT &amp;neighbors, float viewDistance)</td></tr>
<tr class="separator:a7d9e2cbba7557cca0a07982a322c89b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ccbc9d2a2089bcfb651fb70c9f9dc5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a46ccbc9d2a2089bcfb651fb70c9f9dc5"></a>
template&lt;class T , class conT &gt; </td></tr>
<tr class="memitem:a46ccbc9d2a2089bcfb651fb70c9f9dc5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TagObstaclesWithinViewRange</b> (const T &amp;entity, const conT &amp;obstacles, float boxLength)</td></tr>
<tr class="separator:a46ccbc9d2a2089bcfb651fb70c9f9dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99cdd11937d42eb54aea68706b9447c"><td class="memTemplParams" colspan="2"><a class="anchor" id="af99cdd11937d42eb54aea68706b9447c"></a>
template&lt;class T , class conT &gt; </td></tr>
<tr class="memitem:af99cdd11937d42eb54aea68706b9447c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TagNeighbors</b> (const T &amp;entity, const conT &amp;neighbors, float radius)</td></tr>
<tr class="separator:af99cdd11937d42eb54aea68706b9447c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af755c362f3897acf3c563709fb08e478"><td class="memTemplParams" colspan="2"><a class="anchor" id="af755c362f3897acf3c563709fb08e478"></a>
template&lt;class T , class conT &gt; </td></tr>
<tr class="memitem:af755c362f3897acf3c563709fb08e478"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TagObstacles</b> (const T &amp;entity, const conT &amp;obstacles, float radius)</td></tr>
<tr class="separator:af755c362f3897acf3c563709fb08e478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a8bb3e99f2db51489abc61f130cf0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#ac9a8bb3e99f2db51489abc61f130cf0f">TwoCirclesOverlapped</a> (float x1, float y1, float r1, float x2, float y2, float r2)</td></tr>
<tr class="memdesc:ac9a8bb3e99f2db51489abc61f130cf0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for circle-to-circle overlap.  <a href="#ac9a8bb3e99f2db51489abc61f130cf0f"></a><br/></td></tr>
<tr class="separator:ac9a8bb3e99f2db51489abc61f130cf0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9be81ad47052543fb184597934f48f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#abc9be81ad47052543fb184597934f48f">TwoCirclesOverlapped</a> (<a class="el" href="structsteer_1_1_vector2.html">Vector2</a> c1, float r1, <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> c2, float r2)</td></tr>
<tr class="memdesc:abc9be81ad47052543fb184597934f48f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests for circle-to-circle overlap.  <a href="#abc9be81ad47052543fb184597934f48f"></a><br/></td></tr>
<tr class="separator:abc9be81ad47052543fb184597934f48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275ca98cd49e296b5e438b940607baeb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a275ca98cd49e296b5e438b940607baeb"></a>
template&lt;class T , class conT &gt; </td></tr>
<tr class="memitem:a275ca98cd49e296b5e438b940607baeb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Overlapped</b> (const T *ob, const conT &amp;conOb, float MinDistBetweenObstacles)</td></tr>
<tr class="separator:a275ca98cd49e296b5e438b940607baeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60de043149c12ac3a88fa7984609751c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a60de043149c12ac3a88fa7984609751c">LineIntersection2D</a> (<a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> A, <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> B, <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> C, <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> D, float &amp;dist, <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;point)</td></tr>
<tr class="memdesc:a60de043149c12ac3a88fa7984609751c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for an intersection between two lines, given beginning and end points for both lines.  <a href="#a60de043149c12ac3a88fa7984609751c"></a><br/></td></tr>
<tr class="separator:a60de043149c12ac3a88fa7984609751c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873d9abe2a1b506e7b98698181cde7fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a873d9abe2a1b506e7b98698181cde7fb">WrapAround</a> (<a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;pos, int MaxX, int MaxY)</td></tr>
<tr class="memdesc:a873d9abe2a1b506e7b98698181cde7fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the vector useful for wrapping around the steering vector of an agent to fit in the bounds of a rectangle (the screen, for example).  <a href="#a873d9abe2a1b506e7b98698181cde7fb"></a><br/></td></tr>
<tr class="separator:a873d9abe2a1b506e7b98698181cde7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b663063284092ac7ab7ce102537577"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab4b663063284092ac7ab7ce102537577"></a>
template&lt;class T , class N &gt; </td></tr>
<tr class="memitem:ab4b663063284092ac7ab7ce102537577"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calculateTarget</b> (const T &amp;agent, const N &amp;other)</td></tr>
<tr class="separator:ab4b663063284092ac7ab7ce102537577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c14b47b11e070f4950a1aee6540c01"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad5c14b47b11e070f4950a1aee6540c01"></a>
template&lt;class T , class N , class P &gt; </td></tr>
<tr class="memitem:ad5c14b47b11e070f4950a1aee6540c01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calculateTarget</b> (const T &amp;agent, const N &amp;otherA, const P &amp;otherB)</td></tr>
<tr class="separator:ad5c14b47b11e070f4950a1aee6540c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2a379977815aa62658d18699956c10"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4a2a379977815aa62658d18699956c10"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4a2a379977815aa62658d18699956c10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Seek</b> (const T &amp;agent)</td></tr>
<tr class="separator:a4a2a379977815aa62658d18699956c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f488edeb6cd89274a14366eb3a7e1c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a92f488edeb6cd89274a14366eb3a7e1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a92f488edeb6cd89274a14366eb3a7e1c">Seek</a> (const T &amp;agent, <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> target)</td></tr>
<tr class="memdesc:a92f488edeb6cd89274a14366eb3a7e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function returning the value necessary to steer an agent towards a target.  <a href="#a92f488edeb6cd89274a14366eb3a7e1c"></a><br/></td></tr>
<tr class="separator:a92f488edeb6cd89274a14366eb3a7e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bb9c71a340f94f6f6ddb83c4687794"><td class="memTemplParams" colspan="2"><a class="anchor" id="a64bb9c71a340f94f6f6ddb83c4687794"></a>
template&lt;class T , class conT &gt; </td></tr>
<tr class="memitem:a64bb9c71a340f94f6f6ddb83c4687794"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Alignment</b> (const T &amp;agent, const conT &amp;neighbors)</td></tr>
<tr class="separator:a64bb9c71a340f94f6f6ddb83c4687794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac649e70536c11824179384d0f3691229"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac649e70536c11824179384d0f3691229"></a>
template&lt;class T , class conT &gt; </td></tr>
<tr class="memitem:ac649e70536c11824179384d0f3691229"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Separation</b> (const T &amp;agent, const conT &amp;neighbors)</td></tr>
<tr class="separator:ac649e70536c11824179384d0f3691229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd211d8f4c74ca65137f16f5131eca0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fd211d8f4c74ca65137f16f5131eca0"></a>
template&lt;class T , class conT &gt; </td></tr>
<tr class="memitem:a1fd211d8f4c74ca65137f16f5131eca0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cohesion</b> (const T &amp;agent, const conT &amp;neighbors)</td></tr>
<tr class="separator:a1fd211d8f4c74ca65137f16f5131eca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab557c11c5fba2631820b9f184fc20591"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab557c11c5fba2631820b9f184fc20591"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ab557c11c5fba2631820b9f184fc20591"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Arrive</b> (const T &amp;agent, Uint32 deceleration)</td></tr>
<tr class="separator:ab557c11c5fba2631820b9f184fc20591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cc978d5bf37be9d1e57014414a904e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a02cc978d5bf37be9d1e57014414a904e"></a>
template&lt;class T , class N &gt; </td></tr>
<tr class="memitem:a02cc978d5bf37be9d1e57014414a904e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Pursuit</b> (const T &amp;agent, const N &amp;evader)</td></tr>
<tr class="separator:a02cc978d5bf37be9d1e57014414a904e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d413b52056c230d68f9ed386b3ded29"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d413b52056c230d68f9ed386b3ded29"></a>
template&lt;class T , class N &gt; </td></tr>
<tr class="memitem:a0d413b52056c230d68f9ed386b3ded29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>OffsetPursuit</b> (const T &amp;agent, const N &amp;leader, const <a class="el" href="structsteer_1_1_behavior_parameters.html">steer::BehaviorParameters</a> &amp;parameters)</td></tr>
<tr class="separator:a0d413b52056c230d68f9ed386b3ded29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47d67a7d16499e4472eca2935cd7971"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac47d67a7d16499e4472eca2935cd7971"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac47d67a7d16499e4472eca2935cd7971"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Flee</b> (const T &amp;agent)</td></tr>
<tr class="separator:ac47d67a7d16499e4472eca2935cd7971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a02fe7c1f5fcfd39df1d1e81c000e2c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9a02fe7c1f5fcfd39df1d1e81c000e2c"></a>
template&lt;class T , class N &gt; </td></tr>
<tr class="memitem:a9a02fe7c1f5fcfd39df1d1e81c000e2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Evade</b> (const T &amp;agent, const N &amp;other)</td></tr>
<tr class="separator:a9a02fe7c1f5fcfd39df1d1e81c000e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c11f7ee0663f57db131206e0e0a188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#ab3c11f7ee0663f57db131206e0e0a188">findPosition</a> (const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;goalPosition, const float radius, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;avoidPosition, float distanceBuffer)</td></tr>
<tr class="memdesc:ab3c11f7ee0663f57db131206e0e0a188"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates a position located on the other side of some position in space, given a radius, that is out of reach from an undesirable position (for example, a pursuing agent).  <a href="#ab3c11f7ee0663f57db131206e0e0a188"></a><br/></td></tr>
<tr class="separator:ab3c11f7ee0663f57db131206e0e0a188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f567ed70905af9dfc3cd099cc355e57"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f567ed70905af9dfc3cd099cc355e57"></a>
template&lt;class T , class N , class conT &gt; </td></tr>
<tr class="memitem:a7f567ed70905af9dfc3cd099cc355e57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Hide</b> (const T &amp;agent, const N &amp;other, const conT &amp;obstacles, const <a class="el" href="structsteer_1_1_behavior_parameters.html">steer::BehaviorParameters</a> &amp;parameters)</td></tr>
<tr class="separator:a7f567ed70905af9dfc3cd099cc355e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c6f945fad70eb64f596b6f2b7175ce"><td class="memTemplParams" colspan="2"><a class="anchor" id="a27c6f945fad70eb64f596b6f2b7175ce"></a>
template&lt;class T , class N , class P &gt; </td></tr>
<tr class="memitem:a27c6f945fad70eb64f596b6f2b7175ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Interpose</b> (const T &amp;agent, const N &amp;otherA, const P &amp;otherB, const <a class="el" href="structsteer_1_1_behavior_parameters.html">steer::BehaviorParameters</a> &amp;parameters)</td></tr>
<tr class="separator:a27c6f945fad70eb64f596b6f2b7175ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf2f7fb4611cf711bdc56d13e2d3215"><td class="memTemplParams" colspan="2"><a class="anchor" id="acdf2f7fb4611cf711bdc56d13e2d3215"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acdf2f7fb4611cf711bdc56d13e2d3215"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Wander</b> (const T &amp;agent)</td></tr>
<tr class="separator:acdf2f7fb4611cf711bdc56d13e2d3215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3f94518185f2080e8e3bdbe7a55ca9"><td class="memTemplParams" colspan="2"><a class="anchor" id="add3f94518185f2080e8e3bdbe7a55ca9"></a>
template&lt;class T , class conT &gt; </td></tr>
<tr class="memitem:add3f94518185f2080e8e3bdbe7a55ca9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ObstacleAvoidance</b> (const T &amp;agent, const conT &amp;obstacles, const <a class="el" href="structsteer_1_1_behavior_parameters.html">steer::BehaviorParameters</a> &amp;parameters)</td></tr>
<tr class="separator:add3f94518185f2080e8e3bdbe7a55ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6179f09888dc8685aa8b52c2afc377"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c6179f09888dc8685aa8b52c2afc377"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6c6179f09888dc8685aa8b52c2afc377"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>WallAvoidance</b> (const T &amp;agent, const std::vector&lt; <a class="el" href="classsteer_1_1_wall.html">steer::Wall</a> * &gt; &amp;walls)</td></tr>
<tr class="separator:a6c6179f09888dc8685aa8b52c2afc377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64570a33da096432dba7a3d19dcf1b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="af64570a33da096432dba7a3d19dcf1b8"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:af64570a33da096432dba7a3d19dcf1b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PathFollowing</b> (const T &amp;agent, <a class="el" href="classsteer_1_1_path.html">steer::Path</a> *path, const <a class="el" href="structsteer_1_1_behavior_parameters.html">steer::BehaviorParameters</a> &amp;params)</td></tr>
<tr class="separator:af64570a33da096432dba7a3d19dcf1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254eb8e4d720d0f70f0177a680ad37ad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a254eb8e4d720d0f70f0177a680ad37ad">WorldTransform</a> (std::vector&lt; <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &gt; &amp;points, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;pos, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;forward, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;side, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;scale)</td></tr>
<tr class="memdesc:a254eb8e4d720d0f70f0177a680ad37ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a std::vector of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a>, a position, orientation, and scale, this function transforms the std::vector of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> into the object's world space.  <a href="#a254eb8e4d720d0f70f0177a680ad37ad"></a><br/></td></tr>
<tr class="separator:a254eb8e4d720d0f70f0177a680ad37ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af402cf7f7bd95b6b47f5dce33e9eb190"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#af402cf7f7bd95b6b47f5dce33e9eb190">WorldTransform</a> (std::vector&lt; <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &gt; &amp;points, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;pos, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;forward, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;side)</td></tr>
<tr class="memdesc:af402cf7f7bd95b6b47f5dce33e9eb190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a std::vector of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a>, a position, and orientation, this function transforms the std::vector of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> into the object's world space.  <a href="#af402cf7f7bd95b6b47f5dce33e9eb190"></a><br/></td></tr>
<tr class="separator:af402cf7f7bd95b6b47f5dce33e9eb190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17cb909cb8d7f4c1dd087c84bbd7320e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a17cb909cb8d7f4c1dd087c84bbd7320e">PointToWorldSpace</a> (const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;point, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;AgentHeading, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;AgentSide, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;AgentPosition)</td></tr>
<tr class="memdesc:a17cb909cb8d7f4c1dd087c84bbd7320e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a point from the agent's local space into world space.  <a href="#a17cb909cb8d7f4c1dd087c84bbd7320e"></a><br/></td></tr>
<tr class="separator:a17cb909cb8d7f4c1dd087c84bbd7320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12c0f03d4fdf7cd6d9a1cb0eb4e44d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#aa12c0f03d4fdf7cd6d9a1cb0eb4e44d6">VectorToWorldSpace</a> (const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;vec, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;AgentHeading, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;AgentSide)</td></tr>
<tr class="memdesc:aa12c0f03d4fdf7cd6d9a1cb0eb4e44d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a vector from the agent's local space into world space.  <a href="#aa12c0f03d4fdf7cd6d9a1cb0eb4e44d6"></a><br/></td></tr>
<tr class="separator:aa12c0f03d4fdf7cd6d9a1cb0eb4e44d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2250b386a895ce7b5d655598f2510469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a2250b386a895ce7b5d655598f2510469">PointToLocalSpace</a> (const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;point, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;AgentHeading, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;AgentSide, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;AgentPosition)</td></tr>
<tr class="memdesc:a2250b386a895ce7b5d655598f2510469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a vector from world space into the agent's local space.  <a href="#a2250b386a895ce7b5d655598f2510469"></a><br/></td></tr>
<tr class="separator:a2250b386a895ce7b5d655598f2510469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa126e571dabf8b757cb02fd4d891b805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#aa126e571dabf8b757cb02fd4d891b805">VectorToLocalSpace</a> (const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;vec, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;AgentHeading, const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;AgentSide)</td></tr>
<tr class="memdesc:aa126e571dabf8b757cb02fd4d891b805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms a vector from world space into the agent's local space.  <a href="#aa126e571dabf8b757cb02fd4d891b805"></a><br/></td></tr>
<tr class="separator:aa126e571dabf8b757cb02fd4d891b805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf07b9c3ceca3a265cf2e6b45580ff6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#acf07b9c3ceca3a265cf2e6b45580ff6d">Vec2DRotateAroundOrigin</a> (<a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;v, float ang)</td></tr>
<tr class="memdesc:acf07b9c3ceca3a265cf2e6b45580ff6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates a vector by an angle in radians around the origin.  <a href="#acf07b9c3ceca3a265cf2e6b45580ff6d"></a><br/></td></tr>
<tr class="separator:acf07b9c3ceca3a265cf2e6b45580ff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd4285a89a4b46d9bfc1e307f490dbb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#adfd4285a89a4b46d9bfc1e307f490dbb">CreateWhiskers</a> (unsigned int NumWhiskers, float WhiskerLength, float fov, <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> facing, <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> origin)</td></tr>
<tr class="memdesc:adfd4285a89a4b46d9bfc1e307f490dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an origin, a facing direction, a 'field of view' describing the limit of the outer whiskers, a whisker length and the number of whiskers this method returns a vector containing the end positions of a series of whiskers radiating away from the origin and with equal distance between them. (like the spokes of a wheel clipped to a specific segment size);.  <a href="#adfd4285a89a4b46d9bfc1e307f490dbb"></a><br/></td></tr>
<tr class="separator:adfd4285a89a4b46d9bfc1e307f490dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a356a56f949c6f8028f41be63b9648"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2a356a56f949c6f8028f41be63b9648"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2a356a56f949c6f8028f41be63b9648"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isNaN</b> (T val)</td></tr>
<tr class="separator:ac2a356a56f949c6f8028f41be63b9648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631f62487353e649f14584d5cc37e5b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a631f62487353e649f14584d5cc37e5b2"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>DegreesToRadians</b> (float degrees)</td></tr>
<tr class="separator:a631f62487353e649f14584d5cc37e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299284ee5c45b4163a274a313769b985"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a299284ee5c45b4163a274a313769b985">IsZero</a> (float val)</td></tr>
<tr class="memdesc:a299284ee5c45b4163a274a313769b985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the parameter is equal to zero.  <a href="#a299284ee5c45b4163a274a313769b985"></a><br/></td></tr>
<tr class="separator:a299284ee5c45b4163a274a313769b985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2542d4abfc6cc5317ba4147133ea48d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#af2542d4abfc6cc5317ba4147133ea48d">InRange</a> (float start, float end, float val)</td></tr>
<tr class="memdesc:af2542d4abfc6cc5317ba4147133ea48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the third parameter is in the range described by the first two parameters.  <a href="#af2542d4abfc6cc5317ba4147133ea48d"></a><br/></td></tr>
<tr class="separator:af2542d4abfc6cc5317ba4147133ea48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f04d71c01836ce791d0f769c4d95f1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3f04d71c01836ce791d0f769c4d95f1d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3f04d71c01836ce791d0f769c4d95f1d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Maximum</b> (const T &amp;v1, const T &amp;v2)</td></tr>
<tr class="separator:a3f04d71c01836ce791d0f769c4d95f1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b36c18ea42e350b735fdc3354185712"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a5b36c18ea42e350b735fdc3354185712">RandInt</a> (int x, int y)</td></tr>
<tr class="memdesc:a5b36c18ea42e350b735fdc3354185712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random integer between x and y.  <a href="#a5b36c18ea42e350b735fdc3354185712"></a><br/></td></tr>
<tr class="separator:a5b36c18ea42e350b735fdc3354185712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b962bc6a04b703f282696dcd19804a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b962bc6a04b703f282696dcd19804a0"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a6b962bc6a04b703f282696dcd19804a0">RandFloat</a> ()</td></tr>
<tr class="memdesc:a6b962bc6a04b703f282696dcd19804a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random float between 1 and the maximum value for a float. <br/></td></tr>
<tr class="separator:a6b962bc6a04b703f282696dcd19804a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1e45e598d82a4fa251ff00f68df616"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#ace1e45e598d82a4fa251ff00f68df616">RandInRange</a> (float x, float y)</td></tr>
<tr class="memdesc:ace1e45e598d82a4fa251ff00f68df616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random float between x and y.  <a href="#ace1e45e598d82a4fa251ff00f68df616"></a><br/></td></tr>
<tr class="separator:ace1e45e598d82a4fa251ff00f68df616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b5e00f4b545ddc843bd5669bb6df92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1b5e00f4b545ddc843bd5669bb6df92"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#aa1b5e00f4b545ddc843bd5669bb6df92">RandBool</a> ()</td></tr>
<tr class="memdesc:aa1b5e00f4b545ddc843bd5669bb6df92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true or false randomly. <br/></td></tr>
<tr class="separator:aa1b5e00f4b545ddc843bd5669bb6df92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7784de28ffa4a247369c2692e17ce423"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7784de28ffa4a247369c2692e17ce423"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a7784de28ffa4a247369c2692e17ce423">RandomClamped</a> ()</td></tr>
<tr class="memdesc:a7784de28ffa4a247369c2692e17ce423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random float in the range -1 &lt; n &lt; 1. <br/></td></tr>
<tr class="separator:a7784de28ffa4a247369c2692e17ce423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa827e0c23a91ed39816b5a57f255670"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#aaa827e0c23a91ed39816b5a57f255670">RandGaussian</a> (float mean=0.0, float standard_deviation=1.0)</td></tr>
<tr class="memdesc:aaa827e0c23a91ed39816b5a57f255670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random number with a normal distribution. See method at <a href="http://www.taygeta.com/random/gaussian.html">http://www.taygeta.com/random/gaussian.html</a>.  <a href="#aaa827e0c23a91ed39816b5a57f255670"></a><br/></td></tr>
<tr class="separator:aaa827e0c23a91ed39816b5a57f255670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d45ec24b828cfc1feeb41da8c8b5d7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a53d45ec24b828cfc1feeb41da8c8b5d7">Sigmoid</a> (float input, float response=1.0)</td></tr>
<tr class="memdesc:a53d45ec24b828cfc1feeb41da8c8b5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a value from the sigmoid (S-curve) function based on input and response.  <a href="#a53d45ec24b828cfc1feeb41da8c8b5d7"></a><br/></td></tr>
<tr class="separator:a53d45ec24b828cfc1feeb41da8c8b5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58689664dbe73f69b7652a3183e69c53"><td class="memTemplParams" colspan="2"><a class="anchor" id="a58689664dbe73f69b7652a3183e69c53"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a58689664dbe73f69b7652a3183e69c53"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MaxOf</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a58689664dbe73f69b7652a3183e69c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217837f04be9717f24cf243954995f59"><td class="memTemplParams" colspan="2"><a class="anchor" id="a217837f04be9717f24cf243954995f59"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a217837f04be9717f24cf243954995f59"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MinOf</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a217837f04be9717f24cf243954995f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ad745a701b1b29ac15922e6f0b8ac2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a79ad745a701b1b29ac15922e6f0b8ac2"></a>
template&lt;class T , class U , class V &gt; </td></tr>
<tr class="memitem:a79ad745a701b1b29ac15922e6f0b8ac2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Clamp</b> (T &amp;arg, const U &amp;minVal, const V &amp;maxVal)</td></tr>
<tr class="separator:a79ad745a701b1b29ac15922e6f0b8ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dff5dd426bb2760e58cff4184b8452"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#ae6dff5dd426bb2760e58cff4184b8452">Rounded</a> (float val)</td></tr>
<tr class="memdesc:ae6dff5dd426bb2760e58cff4184b8452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds a double up or down depending on its value.  <a href="#ae6dff5dd426bb2760e58cff4184b8452"></a><br/></td></tr>
<tr class="separator:ae6dff5dd426bb2760e58cff4184b8452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbc7df83ecb016c7ae78655e246e8cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a9cbc7df83ecb016c7ae78655e246e8cf">RoundUnderOffset</a> (float val, float offset)</td></tr>
<tr class="memdesc:a9cbc7df83ecb016c7ae78655e246e8cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">rounds a double up or down depending on whether its mantissa is higher or lower than offset.  <a href="#a9cbc7df83ecb016c7ae78655e246e8cf"></a><br/></td></tr>
<tr class="separator:a9cbc7df83ecb016c7ae78655e246e8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523f700d20560f6217fa145c0de7a3f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a523f700d20560f6217fa145c0de7a3f0">isEqual</a> (float a, float b)</td></tr>
<tr class="memdesc:a523f700d20560f6217fa145c0de7a3f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two real numbers. Returns true if they are equal.  <a href="#a523f700d20560f6217fa145c0de7a3f0"></a><br/></td></tr>
<tr class="separator:a523f700d20560f6217fa145c0de7a3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84c23ecc5046c6ef8e22ded45af0f49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#ab84c23ecc5046c6ef8e22ded45af0f49">isEqual</a> (double a, double b)</td></tr>
<tr class="memdesc:ab84c23ecc5046c6ef8e22ded45af0f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two real numbers. Returns true if they are equal.  <a href="#ab84c23ecc5046c6ef8e22ded45af0f49"></a><br/></td></tr>
<tr class="separator:ab84c23ecc5046c6ef8e22ded45af0f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4a3b96d811360acc3dd444e3af8b13"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5a4a3b96d811360acc3dd444e3af8b13"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5a4a3b96d811360acc3dd444e3af8b13"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Average</b> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a5a4a3b96d811360acc3dd444e3af8b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711dccf7b09d3ec93fb355fd267a7483"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a711dccf7b09d3ec93fb355fd267a7483">StandardDeviation</a> (const std::vector&lt; float &gt; &amp;v)</td></tr>
<tr class="memdesc:a711dccf7b09d3ec93fb355fd267a7483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the standard deviation from a std::vector of floats.  <a href="#a711dccf7b09d3ec93fb355fd267a7483"></a><br/></td></tr>
<tr class="separator:a711dccf7b09d3ec93fb355fd267a7483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992945ff2a0d4a6f9ef9270db90c981a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a992945ff2a0d4a6f9ef9270db90c981a"></a>
template&lt;class container &gt; </td></tr>
<tr class="memitem:a992945ff2a0d4a6f9ef9270db90c981a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DeleteSTLContainer</b> (container &amp;c)</td></tr>
<tr class="separator:a992945ff2a0d4a6f9ef9270db90c981a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad536cd984874925d404a37237fa8559"><td class="memTemplParams" colspan="2"><a class="anchor" id="aad536cd984874925d404a37237fa8559"></a>
template&lt;class map &gt; </td></tr>
<tr class="memitem:aad536cd984874925d404a37237fa8559"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DeleteSTLMap</b> (map &amp;m)</td></tr>
<tr class="separator:aad536cd984874925d404a37237fa8559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd35e7e51d88896e49245ded868c538"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bd35e7e51d88896e49245ded868c538"></a>
<a class="el" href="structsteer_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;lhs, double rhs)</td></tr>
<tr class="separator:a2bd35e7e51d88896e49245ded868c538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5864f0d19d94daa684b8a55637c84dc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5864f0d19d94daa684b8a55637c84dc2"></a>
<a class="el" href="structsteer_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (double lhs, const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;rhs)</td></tr>
<tr class="separator:a5864f0d19d94daa684b8a55637c84dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab24ae7b002ad5695b879043aad312b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afab24ae7b002ad5695b879043aad312b"></a>
<a class="el" href="structsteer_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;lhs, const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;rhs)</td></tr>
<tr class="separator:afab24ae7b002ad5695b879043aad312b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ee549bf316a5ec19e91f68d2fa15ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73ee549bf316a5ec19e91f68d2fa15ae"></a>
<a class="el" href="structsteer_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;lhs, const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;rhs)</td></tr>
<tr class="separator:a73ee549bf316a5ec19e91f68d2fa15ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dafca5ac00c59c23bf462fa43d53687"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dafca5ac00c59c23bf462fa43d53687"></a>
<a class="el" href="structsteer_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;lhs, double val)</td></tr>
<tr class="separator:a1dafca5ac00c59c23bf462fa43d53687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2897e317d7cec95885fecace5e6721"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c2897e317d7cec95885fecace5e6721"></a>
<a class="el" href="structsteer_1_1_vector2.html">Vector2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Vec2DNormalize</b> (const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;v)</td></tr>
<tr class="separator:a2c2897e317d7cec95885fecace5e6721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ffa1dbeba5350c659fd4b633d71fc7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20ffa1dbeba5350c659fd4b633d71fc7"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Vec2DDistance</b> (const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;v1, const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;v2)</td></tr>
<tr class="separator:a20ffa1dbeba5350c659fd4b633d71fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90ccef2b4abb712d998e2dce06f7ac3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae90ccef2b4abb712d998e2dce06f7ac3"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Vec2DDistanceSq</b> (const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;v1, const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;v2)</td></tr>
<tr class="separator:ae90ccef2b4abb712d998e2dce06f7ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40eb10235c17dfd4cc99365a2eea239b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40eb10235c17dfd4cc99365a2eea239b"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Vec2DLength</b> (const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;v)</td></tr>
<tr class="separator:a40eb10235c17dfd4cc99365a2eea239b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09905f2e9bf6e2ddf87db9351bfb7f1e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09905f2e9bf6e2ddf87db9351bfb7f1e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>Vec2DLengthSq</b> (const <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> &amp;v)</td></tr>
<tr class="separator:a09905f2e9bf6e2ddf87db9351bfb7f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65ad10b8625684daa28ee9a77a7d6ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae65ad10b8625684daa28ee9a77a7d6ea"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>NotInsideRegion</b> (<a class="el" href="structsteer_1_1_vector2.html">Vector2</a> p, <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> top_left, <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> bot_rgt)</td></tr>
<tr class="separator:ae65ad10b8625684daa28ee9a77a7d6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39e0810dd737d7105e7cd34945a6b14"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af39e0810dd737d7105e7cd34945a6b14"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>InsideRegion</b> (<a class="el" href="structsteer_1_1_vector2.html">Vector2</a> p, <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> top_left, <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> bot_rgt)</td></tr>
<tr class="separator:af39e0810dd737d7105e7cd34945a6b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89da8595b52ce4ebbfce76b79b14d691"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89da8595b52ce4ebbfce76b79b14d691"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>InsideRegion</b> (<a class="el" href="structsteer_1_1_vector2.html">Vector2</a> p, int left, int top, int right, int bottom)</td></tr>
<tr class="separator:a89da8595b52ce4ebbfce76b79b14d691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71a54989ea2d8d78c474d48cfbb2719"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae71a54989ea2d8d78c474d48cfbb2719"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isSecondInFOVOfFirst</b> (<a class="el" href="structsteer_1_1_vector2.html">Vector2</a> posFirst, <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> facingFirst, <a class="el" href="structsteer_1_1_vector2.html">Vector2</a> posSecond, double fov)</td></tr>
<tr class="separator:ae71a54989ea2d8d78c474d48cfbb2719"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac2c05a7a66233029823a2cacbd3f9f12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2c05a7a66233029823a2cacbd3f9f12"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxInt</b> = (std::numeric_limits&lt;int&gt;::max)()</td></tr>
<tr class="separator:ac2c05a7a66233029823a2cacbd3f9f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45300e8fbea49b9bc5b7be6f21c15c7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45300e8fbea49b9bc5b7be6f21c15c7b"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>MaxDouble</b> = (std::numeric_limits&lt;double&gt;::max)()</td></tr>
<tr class="separator:a45300e8fbea49b9bc5b7be6f21c15c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517505ea56a449259f2cc542e417ce93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a517505ea56a449259f2cc542e417ce93"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>MinDouble</b> = (std::numeric_limits&lt;double&gt;::min)()</td></tr>
<tr class="separator:a517505ea56a449259f2cc542e417ce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0e6174813ace40bbb9cb98f0e3c5d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add0e6174813ace40bbb9cb98f0e3c5d7"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><b>MaxFloat</b> = (std::numeric_limits&lt;float&gt;::max)()</td></tr>
<tr class="separator:add0e6174813ace40bbb9cb98f0e3c5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bf68d321f262da821a26567f563f5d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96bf68d321f262da821a26567f563f5d"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesteer.html#a96bf68d321f262da821a26567f563f5d">MinFloat</a> = (std::numeric_limits&lt;float&gt;::min)()</td></tr>
<tr class="memdesc:a96bf68d321f262da821a26567f563f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful constants for Pi. <br/></td></tr>
<tr class="separator:a96bf68d321f262da821a26567f563f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ede252c728122c7e62eae19b4137e3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ede252c728122c7e62eae19b4137e3a"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><b>Pi</b> = 3.14159f</td></tr>
<tr class="separator:a9ede252c728122c7e62eae19b4137e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bcc0c0f0548d243c333a6e8e086242"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78bcc0c0f0548d243c333a6e8e086242"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><b>TwoPi</b> = Pi * 2</td></tr>
<tr class="separator:a78bcc0c0f0548d243c333a6e8e086242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d81a14fa90c76872f3af149cdd97ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96d81a14fa90c76872f3af149cdd97ef"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><b>HalfPi</b> = Pi / 2</td></tr>
<tr class="separator:a96d81a14fa90c76872f3af149cdd97ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcf7f03bead45c81e0c67bc10c49acb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadcf7f03bead45c81e0c67bc10c49acb"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><b>QuarterPi</b> = Pi / 4</td></tr>
<tr class="separator:aadcf7f03bead45c81e0c67bc10c49acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>All steering functions are templated for easy application to objects inheriting from <a class="el" href="classsteer_1_1_agent.html" title="The invisible, but highly necessary, automaton which drives your *game entity/graphical representatio...">Agent</a>. Because of this, it is easy to add into any type of design - be it a class hierarchy or a more advanced data structure or system (such as an entity component system). All functions return a steer::steer::Vector2 that can be used to calculate a force with which the entity should be moved given each type of behavior. Combine each calculated force with a weight (any scalar value - but keep it sane or behavior could become strange). Simply multiply each weight, or weights, by the force generated by each behavior's return value to fine-tune it. In addition to the steering functions themselves, this file contains various utilities used by them to perform their work. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="adfd4285a89a4b46d9bfc1e307f490dbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &gt; steer::CreateWhiskers </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>NumWhiskers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>WhiskerLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td>
          <td class="paramname"><em>facing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given an origin, a facing direction, a 'field of view' describing the limit of the outer whiskers, a whisker length and the number of whiskers this method returns a vector containing the end positions of a series of whiskers radiating away from the origin and with equal distance between them. (like the spokes of a wheel clipped to a specific segment size);. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NumWhiskers</td><td>- a plain old unsigned int. </td></tr>
    <tr><td class="paramname">WhiskerLength</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">facing</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">origin</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3c11f7ee0663f57db131206e0e0a188"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> steer::findPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>goalPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>avoidPosition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>distanceBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function calculates a position located on the other side of some position in space, given a radius, that is out of reach from an undesirable position (for example, a pursuing agent). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">goalPosition</td><td>- a 2D vector of doubles. </td></tr>
    <tr><td class="paramname">radius</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">avoidPosition</td><td>- a 2D vector of doubles. </td></tr>
    <tr><td class="paramname">boundary</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2542d4abfc6cc5317ba4147133ea48d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool steer::InRange </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the third parameter is in the range described by the first two parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">end</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">val</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a523f700d20560f6217fa145c0de7a3f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool steer::isEqual </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two real numbers. Returns true if they are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">b</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab84c23ecc5046c6ef8e22ded45af0f49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool steer::isEqual </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two real numbers. Returns true if they are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>- a plain old double. </td></tr>
    <tr><td class="paramname">b</td><td>- a plain old double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a299284ee5c45b4163a274a313769b985"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool steer::IsZero </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the parameter is equal to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60de043149c12ac3a88fa7984609751c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool steer::LineIntersection2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks for an intersection between two lines, given beginning and end points for both lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- a 2D vector of floats. </td></tr>
    <tr><td class="paramname">B</td><td>- a 2D vector of floats. </td></tr>
    <tr><td class="paramname">C</td><td>- a 2D vector of floats. </td></tr>
    <tr><td class="paramname">D</td><td>- a 2D vector of floats. </td></tr>
    <tr><td class="paramname">dist</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">point</td><td>- a 2D vector of floats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2250b386a895ce7b5d655598f2510469"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> steer::PointToLocalSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>AgentHeading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>AgentSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>AgentPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a vector from world space into the agent's local space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">AgentHeading</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">AgentSide</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">AgentPosition</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17cb909cb8d7f4c1dd087c84bbd7320e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> steer::PointToWorldSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>AgentHeading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>AgentSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>AgentPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a point from the agent's local space into world space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">AgentHeading</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">AgentSide</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">AgentPosition</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa827e0c23a91ed39816b5a57f255670"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float steer::RandGaussian </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>mean</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>standard_deviation</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random number with a normal distribution. See method at <a href="http://www.taygeta.com/random/gaussian.html">http://www.taygeta.com/random/gaussian.html</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mean</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">standard_deviation</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace1e45e598d82a4fa251ff00f68df616"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float steer::RandInRange </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random float between x and y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">y</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b36c18ea42e350b735fdc3354185712"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int steer::RandInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a random integer between x and y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- a plain old int. </td></tr>
    <tr><td class="paramname">y</td><td>- a plain old int. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6dff5dd426bb2760e58cff4184b8452"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int steer::Rounded </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rounds a double up or down depending on its value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9cbc7df83ecb016c7ae78655e246e8cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int steer::RoundUnderOffset </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rounds a double up or down depending on whether its mantissa is higher or lower than offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">offset</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92f488edeb6cd89274a14366eb3a7e1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> steer::Seek </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>agent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function returning the value necessary to steer an agent towards a target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">agent</td><td>- a <a class="el" href="classsteer_1_1_agent.html" title="The invisible, but highly necessary, automaton which drives your *game entity/graphical representatio...">steer::Agent</a> derived object. </td></tr>
    <tr><td class="paramname">target</td><td>- the target vector you are trying to reach. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53d45ec24b828cfc1feeb41da8c8b5d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float steer::Sigmoid </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>response</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a value from the sigmoid (S-curve) function based on input and response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">response</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a711dccf7b09d3ec93fb355fd267a7483"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float steer::StandardDeviation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the standard deviation from a std::vector of floats. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>- a std::vector of floats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9a8bb3e99f2db51489abc61f130cf0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool steer::TwoCirclesOverlapped </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for circle-to-circle overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">y1</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">r1</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">x2</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">y2</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">r2</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abc9be81ad47052543fb184597934f48f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool steer::TwoCirclesOverlapped </td>
          <td>(</td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector2&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests for circle-to-circle overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c1</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">r1</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">c2</td><td>- a plain old float. </td></tr>
    <tr><td class="paramname">r2</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf07b9c3ceca3a265cf2e6b45580ff6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void steer::Vec2DRotateAroundOrigin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rotates a vector by an angle in radians around the origin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">ang</td><td>- a plain old float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa126e571dabf8b757cb02fd4d891b805"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> steer::VectorToLocalSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>AgentHeading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>AgentSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a vector from world space into the agent's local space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">AgentHeading</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">AgentSide</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa12c0f03d4fdf7cd6d9a1cb0eb4e44d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> steer::VectorToWorldSpace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>AgentHeading</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>AgentSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms a vector from the agent's local space into world space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">AgentHeading</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">AgentSide</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a254eb8e4d720d0f70f0177a680ad37ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &gt; steer::WorldTransform </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a std::vector of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a>, a position, orientation, and scale, this function transforms the std::vector of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> into the object's world space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>- a std::vector of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> floats. </td></tr>
    <tr><td class="paramname">pos</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">forward</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">side</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">scale</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af402cf7f7bd95b6b47f5dce33e9eb190"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &gt; steer::WorldTransform </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a std::vector of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a>, a position, and orientation, this function transforms the std::vector of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> into the object's world space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>- a std::vector of <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a>. </td></tr>
    <tr><td class="paramname">pos</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">forward</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
    <tr><td class="paramname">side</td><td>- a <a class="el" href="structsteer_1_1_vector2.html" title="A 2D vector struct used in many steering calculations.">steer::Vector2</a> of floats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a873d9abe2a1b506e7b98698181cde7fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void steer::WrapAround </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsteer_1_1_vector2.html">steer::Vector2</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the vector useful for wrapping around the steering vector of an agent to fit in the bounds of a rectangle (the screen, for example). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>- a 2D vector of floats. </td></tr>
    <tr><td class="paramname">MaxX</td><td>- a plain old int. </td></tr>
    <tr><td class="paramname">MaxY</td><td>- a plain old int. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 10 2017 18:36:37 for Steeriously by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
